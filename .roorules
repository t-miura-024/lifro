# 前提

このファイルの記載内容は AI アシスタントの立場でルールをまとめたものです。

# ルール

## タスクの進め方

### 0. 初回応答時の振る舞い

新規チャット開始時の最初の応答では、必ず以下の対応を行います：

1. ユーザーの依頼/相談内容を確認する
2. タスク化が必要かどうかを判断する（コード実装、機能追加、バグ修正などはタスク化必須）
3. タスク化が必要な場合は、「これはタスクとして管理した方が良さそうですね」と提案する
4. タスク化が不要な場合（単純な質問や相談）のみ、直接回答する

### 1. ユーザーがタスクの依頼/相談をする

New Task からユーザーがタスクの依頼もしくは相談をします。
開発プロセスのサイクルはこのタイミングを起点としてください。
New Task からの依頼や相談でない場合は、当該 Chat の履歴を読み取り、適切なステップから進めてください。

### 2. 起票（タスク化）

このステップは orchestrator モードで実行します。
ユーザーからのコメントが質問や相談である場合、タスク化すべき事案かどうかをユーザーにヒアリングします。

タスク化すべき事案の判断基準：

- コード実装が必要なもの（新機能、バグ修正など）
- 設計変更が必要なもの
- 複数の変更が必要なもの
- 後で追跡が必要なもの

タスク化が不要な事案の例：

- 単純な概念説明
- 一時的なコード例の提示
- 技術的な質問への回答

タスク化する必要があることがわかった場合、GitHub リポジトリ `t-miura-024/lifro` に Issue を作成します。
Issue のタイトルはタスクの内容を簡潔に表すものとし、本文には `docs/issue/template.md` の内容（`# タイトル`行を削除したもの）を適用します。
Issue が作成されたら、このステップを完了とします。

ステップ完了前の確認：「GitHub に Issue を作成しました。次のステップに進んでも良いでしょうか？」

### 3. ユーザーとのタスクのリファインメント（PM 観点）

このステップは、最初は orchestrator モードで実行します。
作成した Issue の内容（特に TODO 部分）をユーザーと対話しながら明確にします。
タスク内容についてはユーザーの意見を重視しますが、必要に応じて AI アシスタントからも提案します。
また、タスクが大きすぎたら分割することを提案します。
タスクを分割する際は、テスト可能で独立した成果物が出せる単位で分割し、それぞれ新しい Issue を作成します。
orchestrator モードでリファインメントを十分に実施できたと判断したら、architect モードに切り替えて、設計と実装の方針についてユーザーと議論しつつ擦り合わせます。
architect モードでもリファインメントを十分に実施できたと判断したら、ユーザーにタスクを準備完了として良いか確認します。
ユーザーからタスクの準備完了の承認が得られたら、このステップを完了とします。

ステップ完了前の確認：「タスク内容のリファインメントが完了し、Issue の状態を更新しました。次のステップに進んでも良いでしょうか？」

### 4. タスクの実行準備

このステップは architect モードまたは code モードで実行します。
ターミナルにて`git status`を実行して、ソースコードの差分を確認します。
ソースコードに差分がある場合は、`git stash -u`を実行することをユーザーに提案します。
ソースコードの差分がない(もしくはなくなった)ことを確認できたら、このステップを完了とします。

ステップ完了前の確認：「ソースコードの差分を確認し、Issue の状態を更新しました。次のステップに進んでも良いでしょうか？」

### 5. タスクの実行

このステップは architect モードまたは code モードで実行します。
該当 Issue の記載内容に従ってタスクを実行します。
当該タスクが実装タスクの場合、TDD のプラクティスに従い、テストコードから実装します。
当該タスクの完了の定義を満たせたと判断したら、ユーザーにタスクを実行完了として良いか確認します。
ユーザーからタスクの実行完了の承認が得られたら、このステップを完了とします。

ステップ完了前の確認：「タスクの実行が完了したと考えています。タスクの完了の定義を満たしていると思いますが、実行完了として良いでしょうか？」

### 6. タスクの実行結果の反映

このステップは architect モードまたは code モードで実行します。
ターミナルにて`git add -A`と`git commit -m "feat: [タスク概要] (#Issue番号)"`を実行してソースコードの差分をコミットします。(コミットメッセージのフォーマットは適宜調整)
コミットし差分がないことを確認できたら、`git push origin main`を実行してリモートブランチに差分を反映させます。
`git push origin main`の実行が完了したら、該当 Issue を close 状態にして、このステップは完了とします。

#### コミット時の注意点

- 必ず`git add -A`を使用して、関連するすべての変更ファイルをコミット対象に含める
- コミット前に`git status`で変更ファイルを確認し、タスクに関連するすべてのファイルがステージングされていることを確認する
- コミットメッセージに Issue 番号を含めることで、Issue とコミットを紐付ける

ステップ完了前の確認：「コミットとプッシュが完了し、Issue の状態を更新しました。振り返りのステップに進んでも良いでしょうか？」

### 7. 振り返り

- このステップは orchestrator モードで実行します。
- 対応内容やユーザーと対話した内容をもとに振り返りを行います。
- 振り返りは YWT（やったこと、わかったこと、次にやること）のフレームワークを使用します
- 振り返りは対話的にステップバイステップで進めます。
- 振り返りの結果は.roorules や.roomodes にも反映させることを検討します。
- 振り返りの結果は該当 Issue にコメントとして記録します。

## ドキュメンテーション

プロジェクトのドキュメントは以下のルールに従って管理します。

### ドキュメントの種類と配置

- 要件定義/要件定義: `docs/requirements/`
- 設計: `docs/design/`
- タスク管理: GitHub Issues (`t-miura-024/lifro`)

### ドキュメントの命名規則

- ファイル名は日本語を使用する
- 拡張子は`.md`を使用

### ドキュメントの更新ルール

- タスクの状態変更時は必ず GitHub Issue を更新
- 設計変更時は必ずドキュメントを更新
- 要件変更時は必ずドキュメントを更新
